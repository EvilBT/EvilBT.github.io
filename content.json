{"meta":{"title":"Android","subtitle":null,"description":"Android开发","author":"sherlock","url":"http://zpayh.xyz"},"pages":[],"posts":[{"title":"基于Agera的EventBus实现库","slug":"基于Agera的EventBus实现库","date":"2016-11-08T13:59:54.000Z","updated":"2016-11-08T14:00:59.536Z","comments":true,"path":"2016/11/08/基于Agera的EventBus实现库/","link":"","permalink":"http://zpayh.xyz/2016/11/08/基于Agera的EventBus实现库/","excerpt":"基于Agera的EventBus实现库AgeraBus简介AgeraBus 是基于谷歌开源的Agera实现的Android事件总线，实现了EventBus基本常用的功能，下面将为你一一介绍，如果要了解Agera，可以去看我文章后面推荐的两个地址。","text":"基于Agera的EventBus实现库AgeraBus简介AgeraBus 是基于谷歌开源的Agera实现的Android事件总线，实现了EventBus基本常用的功能，下面将为你一一介绍，如果要了解Agera，可以去看我文章后面推荐的两个地址。 添加依赖在项目根目录的build.gradle中添加:123456allprojects &#123; repositories &#123; ... maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125; 在app的build.gradle中添加:1234dependencies &#123; compile &apos;com.github.EvilBT:AgeraBus:v1.0.1&apos; compile &apos;com.google.android.agera:agera:1.2.0-beta3&apos;&#125; 基本用法一个事件总线的使用总是少不了订阅、取消、发送事件，还有获取数据，下面我们来看下AgeraBus的基本用法，首先我们定义一个普通的类充当一个事件类型:123456789101112131415public class User&#123; private String mName; public User(String name)&#123; this.mName = name; &#125; public void setName(String name)&#123; this.mName = name; &#125; public String getName()&#123; return this.mName; &#125;&#125; 简单的订阅，注销事件以及获取最新数据：1234567891011121314151617181920212223242526272829303132333435363738394041public class BaseActivity extends Activity implements Updatable&#123; ... @Override protected void onStart() &#123; super.onStart(); //register 同一个Updatable实例只能订阅同一种事件类型一次，如需重新 //订阅，要先取消订阅，如果多次订阅会抛出异常，这里Activity实现了Updatable接口 AgeraBus.getDefault() .addUpdatable(this,User.class); &#125; @Override protected void onStop() &#123; super.onStop(); // unregister 取消订阅时，这个Updatable实例必须已经订阅了此事件， // 如果取消没有订阅的Updatable，会抛出异常 AgeraBus.getDefault() .removeUpdatable(this,User.class); &#125; /** * 接收到事件时调用的接口 * */ @Override public void update() &#123; // accept AgeraBus.getDefault()//获取默认总线 .getSupplier(User.class)//拿到数据提供者 .get()//获取封装好的数据Result&lt;User&gt; .ifSucceededSendTo(new Receiver&lt;User&gt;() &#123;//数据成功接收到就发送给接收者 @Override public void accept(@NonNull User value) &#123; //打印吐司 Toast.makeText(BaseActivity.this, value.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 上面就是最基本的订阅、取消事件以及接收数据。至于发送事件的话，只有一个入口:1AgeraBus.getDefault().post(new User(\"Sherlock\")); 上面就是AgeraBus最基本的用法，下面简单讲解一下， Agera 使用 push event, pull data 模型(推送事件,拉取数据)。 push event：被观察者只做事件通知，不携带任何数据; pull data：观察者根据自己需要从数据仓库(Repository.get())拉取数据。 由于push event, pull data模型是数据和事件通知分离的，所以上面看到的Updatable接口设计上并没有携带数据过来的，我们在update方法里，如果要拉取数据，可以从AgeraBus拿到订阅事件的数据提供者:Supplier,再从Supplier中获取数据。 进阶用法EventBus 提供了线程分发，订阅优先级，取消事件分发，粘性事件，而这些在AgeraBus也都一一实现了。使用这些高级功能时，我们的订阅方法是使用另外一个接口。下面会介绍到。 线程分发与线程模型ThreadMode有四种：PostThread，MainThread，BackgroundThread，Async. PostThread 订阅者将会被调用在与发布线程同样的线程中。上面基本用法就是采取这样的线程分发的，不涉及线程切换，通常是四种模式开销最小的一个。对于简单任务来说这是推荐用法，但使用这个分发模型要小心不要在主线程执行耗时长的任务，避免阻塞主线程。 MainThread 订阅者将会被回调在Android的Main线程中，适用于更新UI而又不无法确定事件来源于哪个线程的情况。 BackgroundThread 订阅者将在后台线程被回调，如果发布线程本身不是主线程，那么行为就跟PostThread一致，如果是在主线程发布事件，会切换到后台线程执行。 Async 订阅者总是在一个单独的线程被回调。订阅优先级你可以在注册订阅者的时候设置优先级改变事件分发的顺序，按优先级从高到低分发事件回调。取消事件分发你可以在接收事件，拿到数据value之后中断之后的事件分发:1AgeraBus.getDefault().cancel(value); value 是从Supplier拿到的事件的数据，在update中调用上面的取消分发，后续的订阅者将不会接收到此次事件。 粘性事件Agera 的 push event, pull data模型天然就是支持粘性事件，它总会保存最近（最新）的值，这样订阅粘性事件总是可以拿到最近（如果有）的数据。 使用方法要使用上面这些高级功能，我们用AgeraBus另外一个接口方法订阅事件：123456AgeraBus.getDefault() .compiler(User.class)//设置订阅事件的类型 .priority(priority)//设置优先级，或者调用.noPriority()不设置优先级(即为默认0优先级） .sticky()//设置为接收粘性事件，或者调用.noSticky()设置为不接收粘性事件(默认不接收粘性事件) .background()//设置分发线程，有background(),main(),posting(),async()对应四个分发模式(默认为posting模式) .compile(updatable);//设置订阅者，完成订阅 订阅事件不要中断链式调用，最后一定要调用compile(Updatable)完成调用 基本用法中的：12AgeraBus.getDefault() .addUpdatable(this,User.class); 就是全部设置了默认的方式(0优先级，不接收粘性事件，posting线程分发)。 注意在不同线程分发时候拿到的数据，不一定是引发这次事件的数据，拿到的数据有可能要比引发事件的数据要新，在Agera Wiki 中文版中有说到，这是因为: 由于 push event, pull data 模型和多线程情况下，观察者可能看不到数据全部的更新记录。 这是特意设计的: 因为大多数情况下(尤其更新app UI), 本来就只需要关心最新的数据。 上面的使用方法可以参考我的这个项目地址 AgeraBus,里面有使用Demo。可以看下AgeraBus的具体实现，由于本人技术水平有限，如有Bug，欢迎讨论。 参考文章zjutkz的要做一个有冒险精神的人！开启漫漫的agera之旅 Agera Wiki 中文版","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zpayh.xyz/tags/Android/"},{"name":"Agera","slug":"Agera","permalink":"http://zpayh.xyz/tags/Agera/"},{"name":"EventBus","slug":"EventBus","permalink":"http://zpayh.xyz/tags/EventBus/"}]},{"title":"Dagger2使用详解","slug":"Dagger2使用详解","date":"2016-07-06T16:49:54.000Z","updated":"2016-07-06T17:03:15.292Z","comments":true,"path":"2016/07/07/Dagger2使用详解/","link":"","permalink":"http://zpayh.xyz/2016/07/07/Dagger2使用详解/","excerpt":"Dagger2 使用详解 前言Dagger2 是一款使用在Java和Android上的依赖注入的一个类库。","text":"Dagger2 使用详解 前言Dagger2 是一款使用在Java和Android上的依赖注入的一个类库。 配置信息使用Android Studio 创建一个新的项目，在Project的 build.gradle文件添加以下内容：1234567buildscript &#123; dependencies &#123; classpath 'me.tatarka:gradle-retrolambda:3.2.4' classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' &#125;&#125; 并在Module下的build.gradle添加以下内容:123456789101112131415apply plugin: 'com.neenbedankt.android-apt'apply plugin: 'me.tatarka.retrolambda'android &#123; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125;dependencies &#123; apt 'com.google.dagger:dagger-compiler:2.4' compile 'com.google.dagger:dagger:2.4' provided 'org.glassfish:javax.annotation:10.0-b28'&#125; 这样就基本完全了Dagger2的配置环境（顺便也配置了支持lambda表达式）。 Dagger2基本使用我们先简单地创建一个类：12345678910111213public class Poetry &#123; private String mPemo; // 用Inject标记构造函数,表示用它来注入到目标对象中去 @Inject public Poetry() &#123; mPemo = \"生活就像海洋\"; &#125; public String getPemo() &#123; return mPemo; &#125;&#125; 然后我们在MainActivity中使用这个类：123456789101112131415161718192021public class MainActivity extends AppCompatActivity &#123; //添加@Inject注解，表示这个mPoetry是需要注入的 @Inject Poetry mPoetry; private TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); &#125; private void initView() &#123; mTextView = (TextView) findViewById(R.id.tv_poetry); mTextView.setText(mPoetry.getPoems()); &#125;&#125; 但是这样直接运行是会出错的，此时这样子在MainActivity中的mPoetry对象是无法被注入的，因为MainActivity不知道去哪里找到它的实例去注入生成，这时我们需要一个连接器Component，让上面这两个类产生联系：12345678910111213//用@Component表示这个接口是一个连接器，能用@Component注解的只//能是interface或者抽象类@Componentpublic interface MainComponent &#123; /** * 需要用到这个连接器的对象，就是这个对象里面有需要注入的属性 * （被标记为@Inject的属性） * 这里inject表示注入的意思，这个方法名可以随意更改，但建议就 * 用inject即可。 */ void inject(MainActivity activity);&#125; 先运行一遍，AS会生成一些类，再修改一下MainActivity:1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity &#123; //添加@Inject注解，表示这个mPoetry是需要注入的 @Inject Poetry mPoetry; private TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 使用Dagger2生成的类 生成组件进行构造，并注入 DaggerMainComponent.builder() .build() .inject(this); initView(); &#125; private void initView() &#123; mTextView = (TextView) findViewById(R.id.tv_poetry); mTextView.setText(mPoetry.getPoems()); &#125;&#125; 运行，如下上面MainActivity中的Poetry实例并不直接由MainActivity类创建，而是由MainActivityComponent类注入生成实例。以上就是一个简单的Dagger2示例。 @Module有时候我们并不能直接在构造函数里面添加@Inject注解，或者类中存在多个构造函数时，@Inject也只能注解其中一个构造函数，不能注解多个构造函数，这里是会产生歧义性，因为Dagger2无法确认调用哪一个构造函数来生成例的实例对象。另外一种情况是我们在项目中引用第三方类库时，也是无法直接在类构造函数中添加@Inject注解的，所以我们需要用到@Module注解了。@Module是用来生产实例来注入对象的，它类似一个工厂，集中创建要注入的类的对象实例。下面我们引用一下Gson库来看看@Module是怎么使用的，创建MainModule类：12345678910111213141516/*@Module注解表示这个类提供生成一些实例用于注入 */@Modulepublic class MainModule &#123; /** * @Provides 注解表示这个方法是用来创建某个实例对象的，这里我们创建返回Gson对象 * 方法名随便，一般用provideXXX结构 * @return 返回注入对象 */ @Provides public Gson provideGson()&#123; return new Gson(); &#125;&#125; 添加完这个类后，我们要与之前写的类产生关联，不然谁知道你这里提供了生成Gson实例的方法啊。修改MainCompontent:123456789101112//这里表示Component会从MainModule类中拿那些用@Provides注解的方法来生成需要注入的实例@Component(modules = MainModule.class)public interface MainComponent &#123; /** * 需要用到这个连接器的对象，就是这个对象里面有需要注入的属性 * （被标记为@Inject的属性） * 这里inject表示注入的意思，这个方法名可以随意更改，但建议就 * 用inject即可。 */ void inject(MainActivity activity);&#125; 这里多了一个依赖，依赖MainModule类中的方法生成Gson实例，我们在MainActivity里注入Gson实例：123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; //添加@Inject注解，表示这个mPoetry是需要注入的 @Inject Poetry mPoetry; @Inject Gson mGson; private TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 使用Dagger2生成的类 生成组件进行构造，并注入 DaggerMainComponent.builder() .build() .inject(this); initView(); &#125; private void initView() &#123; mTextView = (TextView) findViewById(R.id.tv_poetry); String json = mGson.toJson(mPoetry); mTextView.setText(json); &#125;&#125; 运行，结果如下：Component可以依赖多个Module对象，以上的构造方法与生成方法都是无参生成实例的，如果我们带参数应该怎么做了？我们创建多一个PoetryModule用于提供Poetry实例:1234567891011121314151617@Modulepublic class PoetryModule &#123; // 这个方法需要一个String参数，在Dagger2注入中，这些参数也是注入形式的，也就是 // 要有其他对方提供参数poems的生成，不然会造成编译出错 @Provides public Poetry providePoetry(String poems)&#123; return new Poetry(poems); &#125; // 这里提供了一个生成String的方法，在这个Module里生成Poetry实例时，会查找到这里 // 可以为上面提供String类型的参数 @Provides public String providePoems()&#123; return \"只有意志坚强的人，才能到达彼岸\"; &#125;&#125; 修改MainComponent依赖:123456789101112//这里表示Component会从MainModule类中拿那些用@Provides注解的方法来生成需要注入的实例@Component(modules = &#123;MainModule.class,PoetryModule.class&#125;)public interface MainComponent &#123; /** * 需要用到这个连接器的对象，就是这个对象里面有需要注入的属性 * （被标记为@Inject的属性） * 这里inject表示注入的意思，这个方法名可以随意更改，但建议就 * 用inject即可。 */ void inject(MainActivity activity);&#125; 运行，就可以看到不同的诗词了：细心的同学就会发现了，我们提供了两个可以生成Poetry实例的方法，一个是在Poetry类的构造函数时候用@Inject提供的实例创建方法，一个是在PoetryModule中的@Privodes注解的providePoetry方法，而在上面的运行结果中我们发现是调用了PoetryModule提供的方法，这里就要说明一下优先级的问题，在上面这种既在构造函数中用@Inject提供注入来源，也在@Module中用@Privodes注解提供注入来源的，Dagger2是先从@Privodes查找类实例，如果找到了就用@Module提供的方法来创建类实例，如果没有就从构造函数里用@Inject注解的生成类实例，如果二者都没有，则报错，简而言之，就是@Module的优先级高于@Inject。另外这里还要说明一点，在providePoetry(String)方法中，String这个参数也是要注入提供的，必须也要有在同一个连接器里面有提供，其中在构建类实例的时候，会按照以下顺序执行： 从Module中查找类实例创建方法 Module中存在创建方法，则看此创建方法有没有参数 如果有参数，这些参数也是由Component提供的，返回步骤1逐一生成参数类实例，最后再生成最终类实例 如果无参数，则直接由这个方法生成最终类实例 Module中没有创建方法，则从构造函数里面找那个用@Inject注解的构造函数 如果该构造函数有参数，则也是返回到步骤1逐一生成参数类实例，最后调用该构造函数生成类实例 如果该构造函数无参数，则直接调用该构造函数生成类实例 以上就是一次注入生成类实例的生成步骤。 @Scope我们创建多一个Activity，这个Activity也注入了Poetry跟Gson对象:1234567891011121314151617181920212223242526272829public class OtherActivity extends AppCompatActivity &#123; //添加@Inject注解，表示这个mPoetry是需要注入的 @Inject Poetry mPoetry; @Inject Gson mGson; private TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_other); MainComponent.getInstance() .inject(this); initView(); &#125; private void initView() &#123; mTextView = (TextView) findViewById(R.id.tv_poetry); String json = mGson.toJson(mPoetry); String text = json + \",mPoetry:\"+mPoetry; mTextView.setText(text); &#125;&#125; 我们顺便也把MainComponent改成抽象类的形式，并添加返回MainComponent单例的方法,对应添加MainActivity跳转到OtherActivity的方法.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Component(modules = &#123;MainModule.class,PoetryModule.class&#125;)public abstract class MainComponent &#123; /** * 需要用到这个连接器的对象，就是这个对象里面有需要注入的属性 * （被标记为@Inject的属性） * 这里inject表示注入的意思，这个方法名可以随意更改，但建议就 * 用inject即可。 */ abstract void inject(MainActivity activity); abstract void inject(OtherActivity activity); private static MainComponent sComponent; public static MainComponent getInstance()&#123; if (sComponent == null)&#123; sComponent = DaggerMainComponent.builder().build(); &#125; return sComponent; &#125;&#125;public class MainActivity extends AppCompatActivity &#123; //添加@Inject注解，表示这个mPoetry是需要注入的 @Inject Poetry mPoetry; @Inject Gson mGson; private TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 使用Dagger2生成的类 生成组件进行构造，并注入 MainComponent.getInstance() .inject(this); initView(); &#125; private void initView() &#123; mTextView = (TextView) findViewById(R.id.tv_poetry); String json = mGson.toJson(mPoetry); String text = json + \",mPoetry:\"+mPoetry; mTextView.setText(text); findViewById(R.id.open).setOnClickListener(view -&gt; startActivity(new Intent(this,OtherActivity.class))); &#125;&#125; 运行结果如下：可以看到，调用同一个MainComponent实例多次注入的时候每次都重新生成Poetry实例，有时候我们需要只希望生成一个共用实例的时候应该怎么办呢，这里我们就需要用到Dagger2的@Scope属性了，Scope是作用域的意思，我们先自定义一个@Scope注解:1234@Scope@Retention(RetentionPolicy.RUNTIME)public @interface PoetryScope &#123;&#125; 同时在Module与Component加上这个自定义Scope:12345678910111213141516171819202122232425262728293031323334353637383940@PoetryScope@Component(modules = &#123;MainModule.class,PoetryModule.class&#125;)public abstract class MainComponent &#123; /** * 需要用到这个连接器的对象，就是这个对象里面有需要注入的属性 * （被标记为@Inject的属性） * 这里inject表示注入的意思，这个方法名可以随意更改，但建议就 * 用inject即可。 */ abstract void inject(MainActivity activity); abstract void inject(OtherActivity activity); private static MainComponent sComponent; public static MainComponent getInstance()&#123; if (sComponent == null)&#123; sComponent = DaggerMainComponent.builder().build(); &#125; return sComponent; &#125;&#125;@Modulepublic class PoetryModule &#123; // 这个方法需要一个String参数，在Dagger2注入中，这些参数也是注入形式的，也就是 // 要有其他对方提供参数poems的生成，不然会造成编译出错 @PoetryScope @Provides public Poetry providePoetry(String poems)&#123; return new Poetry(poems); &#125; // 这里提供了一个生成String的方法，在这个Module里生成Poetry实例时，会查找到这里 // 可以为上面提供String类型的参数 @Provides public String providePoems()&#123; return \"只有意志坚强的人，才能到达彼岸\"; &#125;&#125; 重新运行：这时你会发现这两个Poetry实例是同一个实例来的，通过实现自定义@Scope注解，标记当前生成对象的使用范围，标识一个类型的注射器只实例化一次，在同一个作用域内，只会生成一个实例，然后在此作用域内共用一个实例。这样看起来很像单例模式，我们可以查看@Singleton其实就是@Scope的一个默认实现而已。当然，你得是同一个Component对象来生成，这点我们应该可以理解的吧。我们可以通过自定义Scope来组织Component的作用域，使得每个Component的作用域清晰明了，各施其职。 组织Component我们在一个项目之中不可能只使用一个Component连接器来注入对象完成注入工作，一般除了一个全局的ApplicationComponent之外，还有一些作用域在Activity/Fragment的Component，Component之间存在依赖关系与从属关系。如果我们已经创建好了一个全局的ApplicationComponent，然后其它的Component刚好需要ApplicationComponent里面的一个全局属性，想要与ApplicationComponent共享同一个实例，这时就需要用到依赖关系了。 依赖方式一个Component可以依赖一个或多个Component，并拿到被依赖Component暴露出来的实例，Component的dependencies属性就是确定依赖关系的实现。这里的有点像数学里面的交集方式，被依赖的Component主动暴露对象给二者共享，如我们在ApplicationModule提供了一个全局的Gson对象，我们想要提供给其他Component时，要在ApplicationComponent显式的提供一个接口:123456789101112131415161718192021@Modulepublic class ApplicationModule &#123; /** * @Provides 注解表示这个方法是用来创建某个实例对象的，这里我们创建返回Gson对象 * 方法名随便，一般用provideXXX结构 * @return 返回注入对象 */ @Singleton @Provides public Gson provideGson()&#123; return new Gson(); &#125;&#125;@Singleton@Component(modules = ApplicationModule.class)public interface ApplicationComponent &#123; Gson getGson();// 暴露Gson对象接口&#125; 并在自定义的MainApplication中初始化它，更改MainComponent:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MainApplication extends Application &#123; private ApplicationComponent mApplicationComponent; private static MainApplication sApplication; public static MainApplication getInstance() &#123; return sApplication; &#125; @Override public void onCreate() &#123; super.onCreate(); sApplication = this; mApplicationComponent = DaggerApplicationComponent.builder().build(); &#125; public ApplicationComponent getApplicationComponent() &#123; return mApplicationComponent; &#125;&#125;//这里表示Component会从MainModule类中拿那些用@Provides注解的方法来生成需要注入的实例@PoetryScope@Component(dependencies = ApplicationComponent.class, modules = &#123;MainModule.class,PoetryModule.class&#125;)public abstract class MainComponent &#123; /** * 需要用到这个连接器的对象，就是这个对象里面有需要注入的属性 * （被标记为@Inject的属性） * 这里inject表示注入的意思，这个方法名可以随意更改，但建议就 * 用inject即可。 */ abstract void inject(MainActivity activity); abstract void inject(OtherActivity activity); private static MainComponent sComponent; public static MainComponent getInstance()&#123; if (sComponent == null)&#123; sComponent = DaggerMainComponent.builder() .applicationComponent(MainApplication.getInstance() .getApplicationComponent()) .build(); &#125; return sComponent; &#125;&#125; 这样就达到了MainComponent依赖ApplicationComponent。并且这里需要注意的是，MainComponent的作用域不能和ApplicationComponent的作用域一样，否则会报错，一般来讲，我们应该对每个Component都定义不同的作用域。 包含方式（从属方式）@SubComponent如果我们需要父组件全部的提供对象，这时我们可以用包含方式而不是用依赖方式，相比于依赖方式，包含方式不需要父组件显式显露对象，就可以拿到父组件全部对象。且SubComponent只需要在父Component接口中声明就可以了。添加多一个AActivity,AComponent:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@Scope@Retention(RetentionPolicy.RUNTIME)public @interface AScope &#123;&#125;@Modulepublic class AModule &#123; @AScope @Provides public Poetry getPoetry()&#123; return new Poetry(\"万物美好\"); &#125;&#125;@AScope@Subcomponent(modules = AModule.class)public interface AComponent &#123; void inject(AActivity activity);&#125;@Singleton@Component(modules = ApplicationModule.class)public interface ApplicationComponent &#123; Gson getGson();// 暴露Gson对象接口 //AComponent plus(); AComponent plus(AModule module);//添加声明&#125;public class MainApplication extends Application &#123; private ApplicationComponent mApplicationComponent; private AComponent mAComponent; private static MainApplication sApplication; public static MainApplication getInstance() &#123; return sApplication; &#125; @Override public void onCreate() &#123; super.onCreate(); sApplication = this; mApplicationComponent = DaggerApplicationComponent.builder().build(); &#125; public ApplicationComponent getApplicationComponent() &#123; return mApplicationComponent; &#125; public AComponent getAComponent() &#123; if (mAComponent == null)&#123; mAComponent = mApplicationComponent.plus(new AModule()); &#125; return mAComponent; &#125;&#125;public class AActivity extends AppCompatActivity &#123; TextView mTextView; @Inject Gson mGson; @Inject Poetry mPoetry; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_a); MainApplication.getInstance() .getAComponent() .inject(this); mTextView = (TextView) findViewById(R.id.text); String text = mPoetry.getPoems()+\",mPoetry:\"+mPoetry+(mGson == null ? \"Gson没被注入\" : \"Gson已经被注入\"); mTextView.setText(text); &#125;&#125; 最后我们在OtherActivity中添加一个按钮跳转到AActivity，运行结果如下: @Qualifier假如在上面的AActivity里面我们想要注入两个不同的Poetry(指peoms不一样)实例，我们可以在AModule下添加多一个生成Poetry的方法:123456789101112131415@Modulepublic class AModule &#123; @AScope @Provides public Poetry getPoetry()&#123; return new Poetry(\"万物美好\"); &#125; @AScope @Provides public Poetry getOtherPoetry()&#123; return new Poetry(\"我在中间\"); &#125;&#125; 但是直接这样做Dagger2是无法区分调用哪个方法生成Poetry实例的，这个时候就需要自定义@Qualifier限定符来匹配注入方法了，添加一个自定义Qualifier并修AMoudule，AActivity:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Qualifier@Documented@Retention(RetentionPolicy.RUNTIME)public @interface PoetryQualifier &#123; String value() default \"\";&#125;@Modulepublic class AModule &#123; @PoetryQualifier(\"A\") @AScope @Provides public Poetry getPoetry()&#123; return new Poetry(\"万物美好\"); &#125; @PoetryQualifier(\"B\") @AScope @Provides public Poetry getOtherPoetry()&#123; return new Poetry(\"我在中间\"); &#125;&#125;public class AActivity extends AppCompatActivity &#123; TextView mTextView; @Inject Gson mGson; // 匹配Module中同样注解的方法 @PoetryQualifier(\"A\") @Inject Poetry mPoetry; // 匹配Module中同样注解的方法 @PoetryQualifier(\"B\") @Inject Poetry mPoetryB; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_a); MainApplication.getInstance() .getAComponent() .inject(this); mTextView = (TextView) findViewById(R.id.text); String text = mPoetry.getPoems()+\",mPoetryA:\"+mPoetry+ mPoetryB.getPoems()+\",mPoetryB:\"+mPoetryB+ (mGson == null ? \"Gson没被注入\" : \"Gson已经被注入\"); mTextView.setText(text); &#125;&#125; 重新编译运行：而Dagger2已经默认帮我们实现了一个@Named:12345678@Qualifier@Documented@Retention(RUNTIME)public @interface Named &#123; /** The name. */ String value() default \"\";&#125; 跟我们自定义的PoetryQualifier其实是一样的。 后记这篇是我参考了其他文章之后自己又重新总结一遍的，错误之处请帮忙指出，大家一起进步。除了以上常用到的注解之外，Dagger还提供了其他一些注解，如Set，Map类的注解，具体可以参考以下文章。 参考Dagger2图文完全教程Google官方MVP+Dagger2架构详解【从零开始搭建android框架系列（6）】Android：dagger2让你爱不释手-基础依赖注入框架篇Android：dagger2让你爱不释手-重点概念讲解、融合篇Android：dagger2让你爱不释手-终结篇Android:Dagger2学习之由浅入深 Demo地址https://github.com/EvilBT/-Dagger2Demo","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zpayh.xyz/tags/Android/"},{"name":"Dagger2","slug":"Dagger2","permalink":"http://zpayh.xyz/tags/Dagger2/"}]},{"title":"Android开发中使用lambda表达式","slug":"Android开发中使用lambda表达式","date":"2016-06-09T04:06:01.000Z","updated":"2016-07-06T17:03:16.336Z","comments":true,"path":"2016/06/09/Android开发中使用lambda表达式/","link":"","permalink":"http://zpayh.xyz/2016/06/09/Android开发中使用lambda表达式/","excerpt":"在Project的build.gradle中添加：123dependencies &#123; classpath 'me.tatarka:gradle-retrolambda:3.2.5' &#125;","text":"在Project的build.gradle中添加：123dependencies &#123; classpath 'me.tatarka:gradle-retrolambda:3.2.5' &#125; 在Module的build.gradle中添加：1apply plugin: 'me.tatarka.retrolambda' 并把jdk设置成1.8的：123456android &#123; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; build更新一下,就可以在代码中使用 lambda语句了。 另外最新版本的Android Studio 2.1.1本身也支持lambda语句了，SDK全部更新到最新的，然后直接在Module的build.gradle添加以下内容：1234567891011android &#123; defaultConfig &#123; jackOptions &#123; enabled true &#125; &#125; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 开启jack功能，这样也可以使用lambda语句，而且这还是原生的，不过我在调试代码的时候，开启jack之后对我引入的其他Module的代码支持不是很好，调试的时候看不到其他Module引过来的类的实例的动态值，所以我还是暂时没用这个功能。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zpayh.xyz/tags/Android/"}]}]}